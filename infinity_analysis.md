# 무한대(Infinity) 값 발생 원인 분석

## 주요 원인 요약

무한대 값이 발생하는 주요 원인은 **0으로 나누기 연산**입니다. 다음 위치에서 발생할 수 있습니다:

## 1. RSI (Relative Strength Index) 계산

**위치**: `feature_engineering.py` 31번 줄
```python
rs = gain / loss
```

**원인**:
- 가격이 **계속 상승만 하는 구간**에서 `loss`가 0이 될 수 있음
- 예: 14일 동안 가격이 하락한 적이 없으면 `loss = 0` → `rs = inf`
- 반대로 계속 하락만 하면 `gain = 0` → `rs = 0` (이건 괜찮음)

**발생 시나리오**:
- 강한 상승 추세 구간 (예: 비트코인 급등장)
- 변동성이 매우 낮은 구간
- 초기 데이터에서 rolling window가 채워지기 전

## 2. 볼린저 밴드 계산

**위치**: `feature_engineering.py` 87-89번 줄 (수정 전)
```python
width = (upper - lower) / sma  # sma가 0이면 무한대
position = (prices - lower) / (upper - lower)  # upper == lower면 무한대
```

**원인**:
- **sma가 0인 경우**: 이론적으로는 불가능하지만, 데이터 오류나 특수 상황에서 발생 가능
- **upper == lower인 경우**: 표준편차가 0인 완전히 평평한 가격 구간
  - 예: 가격이 정확히 같은 값으로 20개 캔들이 유지되는 경우 (거의 없지만 가능)

## 3. CCI (Commodity Channel Index) 계산

**위치**: `feature_engineering.py` 60번 줄 (수정 전)
```python
cci = (tp - sma) / (0.015 * mad)  # mad가 0이면 무한대
```

**원인**:
- **MAD (Mean Absolute Deviation)가 0인 경우**
- 가격이 완전히 일정한 구간 (20개 캔들이 모두 같은 Typical Price)
- 실제로는 거의 없지만, 데이터 오류나 특수 상황에서 가능

## 4. 파생변수 계산들

### 4.1 이동평균 비율
```python
features['price_ma5_ratio'] = df['close'] / ma5  # ma5가 0이면 무한대
```

**원인**:
- 이동평균이 0인 경우 (이론적으로 불가능하지만 데이터 오류 가능)

### 4.2 거래량 비율
```python
features['volume_ma_ratio'] = df['volume'] / volume_ma  # volume_ma가 0이면 무한대
```

**원인**:
- 거래량 이동평균이 0인 경우
- 거래가 전혀 없었던 구간 (거의 없지만 가능)

### 4.3 모멘텀 지표
```python
features['momentum_5'] = df['close'] / close_shift5 - 1  # close_shift5가 0이면 무한대
```

**원인**:
- 과거 가격이 0인 경우 (데이터 오류)

## 5. 실제 발생 가능성 순위

1. **가장 높음**: RSI의 `loss = 0` 경우
   - 실제 시장에서 상승 추세 구간에서 자주 발생 가능
   
2. **중간**: 볼린저 밴드의 `upper == lower` 경우
   - 변동성이 매우 낮은 구간에서 발생 가능
   
3. **낮음**: CCI의 `mad = 0` 경우
   - 거의 발생하지 않지만 가능
   
4. **매우 낮음**: 가격이나 이동평균이 0인 경우
   - 데이터 오류나 특수 상황에서만 발생

## 6. 왜 51,840개 데이터에서 발생했나?

- **더 많은 데이터 = 더 다양한 시장 상황 포함**
- 강한 상승/하락 추세 구간 포함
- 변동성이 매우 낮은 구간 포함
- 초기 rolling window가 채워지는 구간 포함
- 데이터 수집 과정에서의 노이즈나 오류 가능

## 7. 해결 방법 (이미 적용됨)

1. **모든 나누기 연산에 epsilon 추가**: `+ 1e-8`
2. **무한대 값 명시적 처리**: `replace([np.inf, -np.inf], np.nan)`
3. **최종 검증**: `np.nan_to_num()`으로 안전하게 처리

## 결론

무한대 값은 **정상적인 시장 데이터에서도 발생할 수 있는 현상**입니다. 특히:
- RSI 계산에서 상승 추세 구간
- 볼린저 밴드에서 변동성이 매우 낮은 구간
- 초기 데이터에서 rolling window가 채워지는 구간

따라서 **방어적 프로그래밍**이 필수적이며, 모든 나누기 연산에 epsilon을 추가하고 무한대 값을 처리하는 것이 올바른 접근입니다.

